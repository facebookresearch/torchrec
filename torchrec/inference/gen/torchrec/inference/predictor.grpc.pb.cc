// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: predictor.proto

#include "predictor.grpc.pb.h"
#include "predictor.pb.h"

#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
#include <functional>
namespace predictor {

static const char* Predictor_method_names[] = {
    "/predictor.Predictor/Predict",
};

std::unique_ptr<Predictor::Stub> Predictor::NewStub(
    const std::shared_ptr<::grpc::ChannelInterface>& channel,
    const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr<Predictor::Stub> stub(new Predictor::Stub(channel, options));
  return stub;
}

Predictor::Stub::Stub(
    const std::shared_ptr<::grpc::ChannelInterface>& channel,
    const ::grpc::StubOptions& options)
    : channel_(channel),
      rpcmethod_Predict_(
          Predictor_method_names[0],
          options.suffix_for_stats(),
          ::grpc::internal::RpcMethod::NORMAL_RPC,
          channel) {}

::grpc::Status Predictor::Stub::Predict(
    ::grpc::ClientContext* context,
    const ::predictor::PredictionRequest& request,
    ::predictor::PredictionResponse* response) {
  return ::grpc::internal::BlockingUnaryCall<
      ::predictor::PredictionRequest,
      ::predictor::PredictionResponse,
      ::grpc::protobuf::MessageLite,
      ::grpc::protobuf::MessageLite>(
      channel_.get(), rpcmethod_Predict_, context, request, response);
}

void Predictor::Stub::async::Predict(
    ::grpc::ClientContext* context,
    const ::predictor::PredictionRequest* request,
    ::predictor::PredictionResponse* response,
    std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall<
      ::predictor::PredictionRequest,
      ::predictor::PredictionResponse,
      ::grpc::protobuf::MessageLite,
      ::grpc::protobuf::MessageLite>(
      stub_->channel_.get(),
      stub_->rpcmethod_Predict_,
      context,
      request,
      response,
      std::move(f));
}

void Predictor::Stub::async::Predict(
    ::grpc::ClientContext* context,
    const ::predictor::PredictionRequest* request,
    ::predictor::PredictionResponse* response,
    ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::
      Create<::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          stub_->channel_.get(),
          stub_->rpcmethod_Predict_,
          context,
          request,
          response,
          reactor);
}

::grpc::ClientAsyncResponseReader<::predictor::PredictionResponse>*
Predictor::Stub::PrepareAsyncPredictRaw(
    ::grpc::ClientContext* context,
    const ::predictor::PredictionRequest& request,
    ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create<
      ::predictor::PredictionResponse,
      ::predictor::PredictionRequest,
      ::grpc::protobuf::MessageLite,
      ::grpc::protobuf::MessageLite>(
      channel_.get(), cq, rpcmethod_Predict_, context, request);
}

::grpc::ClientAsyncResponseReader<::predictor::PredictionResponse>*
Predictor::Stub::AsyncPredictRaw(
    ::grpc::ClientContext* context,
    const ::predictor::PredictionRequest& request,
    ::grpc::CompletionQueue* cq) {
  auto* result = this->PrepareAsyncPredictRaw(context, request, cq);
  result->StartCall();
  return result;
}

Predictor::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Predictor_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler<
          Predictor::Service,
          ::predictor::PredictionRequest,
          ::predictor::PredictionResponse,
          ::grpc::protobuf::MessageLite,
          ::grpc::protobuf::MessageLite>(
          [](Predictor::Service* service,
             ::grpc::ServerContext* ctx,
             const ::predictor::PredictionRequest* req,
             ::predictor::PredictionResponse* resp) {
            return service->Predict(ctx, req, resp);
          },
          this)));
}

Predictor::Service::~Service() {}

::grpc::Status Predictor::Service::Predict(
    ::grpc::ServerContext* context,
    const ::predictor::PredictionRequest* request,
    ::predictor::PredictionResponse* response) {
  (void)context;
  (void)request;
  (void)response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

} // namespace predictor
